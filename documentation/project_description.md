Our primary objective is to build a minimal prototype of a third-party web widget using Vite. The experiment focuses on creating a "blue div" component that is fully encapsulated using the Shadow DOM. This encapsulation is crucial because it isolates the widget, preventing its styles from interfering with the host website and, just as importantly, protecting the widget from being broken by the website's own CSS. This approach is standard for any component (like a chat bubble or a feedback button) designed to be embedded on websites you don't control.
The key motivation for this prototype is to solve the critical deployment challenges that previous attempts failed to overcome. Past versions worked in controlled environmentsâ€”either locally or when the widget and the test site were hosted on the same domain. This setup, however, isn't a real-world scenario. The moment the widget was served from a different origin than the host page, it broke due to browser security policies, most notably Cross-Origin Resource Sharing (CORS) errors.
This project, therefore, prioritizes the delivery mechanism above all else. By starting with a minimal component, our entire focus is on correctly configuring the Vite build process and the Firebase hosting environment to explicitly solve these cross-domain issues, particularly by setting the correct CORS headers. This simple "blue div" prototype is a proof-of-concept; once it successfully works and is embeddable on any external website, it will serve as the reliable, documented foundation upon which the full, feature-rich application can be confidently built.
Here's the summary of the plan, updated to include your GitHub deployment workflow.
First, we'll get everything built and tested on your local Windows machine. This initial phase involves opening your project folder in VS Code, installing Node.js, and using npm to create a new, minimal Vite project. We'll immediately configure Vite to build a single JavaScript "library" file instead of a full website. Then, we'll write the code for our <blue-widget> component, using the Shadow DOM to ensure its styles are completely encapsulated. Once we run the npm run build command, we'll have a dist folder containing the final blue-widget.js file, which is the only thing we'll need to deploy.
Next, we'll set up the automated deployment pipeline you mentioned. We'll create a new project in the Firebase console (what you're calling Firebase Studio) and also create a new, empty repository on GitHub. We will push our entire project's source code (including the src folder, package.json, and vite.config.js) to this GitHub repository. Then, inside the Firebase console, we will connect our Firebase Hosting service to this new GitHub repository, which sets up a CI/CD (Continuous Integration/Continuous Deployment) workflow. As part of this setup, we'll also commit the firebase.json file, which we will edit to include the crucial CORS headers (Access-Control-Allow-Origin: *) that allow any website to access our file.
Finally, the deployment and verification will be simple and automatic. From now on, whenever you push any changes to your GitHub repository, it will automatically trigger Firebase to run your npm run build command on its own servers. Firebase will then deploy the resulting dist folder and apply your CORS rules from the firebase.json file. Once the deployment is live, we'll just copy the public URL of the script file from the Firebase console, paste it into an external, third-party website sandbox (like Codepen or JSFiddle), and add the <blue-widget> tag to the HTML. If the blue div appears, our prototype is a complete success.

